Cell Society Design
==================

## Introduction

One of the problems that have been identified in the Cell Society project is how to organize a program that will be flexible enough to support many different Cell Automata. We want to be able to add a new type of simulation in the future and have to change as little of our existing code as possible. Thus, as the factors that determine the behavior of a simulations are the rules by which it lives. Thus, our team decided to encapsulate all of the rules per game, so that the program is extensible. Each cell will have a state, which will update on the coming of the next time tick. The cells are generic and and contain a state. This state will have different information, depending on which simulation is being run. This state object will have rules that are pertinent to it. The UI will consist of a screen in which the user sees the current state of the grid. This will change on each time tick. The user will be able to adjust key values for different simulations. The user will also be able to pause and unpause the simulation, and pick a new simulation. We look to have an organized design that facilitates easy testing, debugging and refactoring. 

## Overview

This section serves as a map of your design for other programmers to gain a general understanding of how and why the program was divided up, and how the individual parts work together to provide the desired functionality. As such, it should describe specific components you intend to create, their purpose with regards to the program's functionality, and how they collaborate with each other. It should also include a picture of how the components are related (these pictures can be hand drawn and scanned in, created with a standard drawing program, or screen shots from a UML design program). This section should discuss specific classes, methods, and data structures, but not individual lines of code.

## User Interface

This section describes how the user will interact with your program (keep it very simple to start). It should describe the overall appearance of program's user interface components and how users interact with these components (especially those specific to your program, i.e., means of input other than menus or toolbars). It should also include one or more pictures of the user interface (these pictures can be hand drawn and scanned in, created with a standard drawing program, or screen shots from a dummy program that serves as a exemplar). Finally, it should describe any erroneous situations that are reported to the user (i.e., bad input data, empty data, etc.). This section should go into as much detail as necessary to cover all your team wants to say.


## Design Details 

This section describes each component introduced in the Overview in detail (as well as any other sub-components that may be needed but are not significant to include in a high-level description of the program). It should describe how each component handles specific features given in the assignment specification, what resources it might use, how it collaborates with other components, and how each could be extended to include additional requirements (from the assignment specification or discussed by your team). Include the steps needed to complete the Use Cases below to help make your descriptions more concrete. Finally, justify the decision to create each component with respect to the design's key goals, principles, and abstractions. This section should go into as much detail as necessary to cover all your team wants to say.
### Details
The Game class will handle reading in of the xml file with the initial configurations and parameter values. These will be different for each game, so we will make an inheritance hierarchy and subclass for each new type of simulation that we are required to implement. The Game subclasses will also dictate which type of state gets which rules. This is important as an extensibility feature so that we have to change existing code as little as possible. The simulation class will be holding the game loop. This is what will have the time ticks of the simulation. The Grid class will have a grid object that contains a cells in a structure. The grid class will be part of UI as well. Since each cell has a state instance variable, this also tells the UI what color to display the cell in. Thus, Grid is a bridge between the backend and the frontend. The cell class will handle the operations of the game related to its neighboring cells. The cell will have a set of rules. There will be a method to get the adjacent cells of the cell. The cell will also have a move() method, which will be invoked on each time tick. This method will take in the adjacent cells' states and the use the cell's own state and act on this information according to the cell's rules. The rules class will have subclasses for each of the games we need to implement as well. Since a cell's state can defines rules within a game, we don't need to subclass for all the possible states. Instead, we subclass for the separate simulations and the state will determine the rules that are applied to that cell on that time tick. The cell will have an instance of a rules object and will use that in its move method. This setup is again done for extensibility purposes. The rules are determined by each type of simulation. These are if (condition) then (outcome) statements that operate on states of adjacent cells. On the UI side, the grid will handle the status of the grid and updating the colors as the simulation runs. We will also have a class to handle the inputs and outputs to the UI. These include the sliders, the menus and updating the indicators based on what simulation is running. It is important to separate UI from backend. This is done to make code more readable, organized, and easier to debug and test. There will be a Main class in the root of the project which will just be responsible for loading up the window and launching the program from the beginning. 
### Use Cases
#### Apply the rules to a middle cell: set the next state of a cell to dead by counting its number of neighbors using the Game of Life rules for a cell in the middle (i.e., with all its neighbors)
The cell will retrieve a list of its neighbors. Then, taking into account its state and the states of all of its neighbors, the cell will change (or not) according to the rule that it is acting by. If the cell changes state, this will be reflected in the visualization. If not, then the cell will remain the same as it was on the previous time tick. On a change of the state, the rules of the cell also changes.
#### Apply the rules to an edge cell: set the next state of a cell to live by counting its number of neighbors using the Game of Life rules for a cell on the edge (i.e., with some of its neighbors missing)
Similarly, the cell will retrieve a list of its neighbors. Next, using its state and the state of all of its neighbors, the cell will act according to the rules that has been assigned to it. If the state of the cell changes, the rules assigned to it will change accordingly. 
#### Move to the next generation: update all cells in a simulation from their current state to their next state and display the result graphically
The Simulation class will maintain the game loop. On each time tick of the simulation, all cells in the grid will be told to update. This means to analyze the states of all the surrounding cells and chose to take an action (different actions depending on which simulation is being run). Once every cell has chosen which action to take, the program will run through and resolve all conflicts (eg two fish try to move to the same cell). The states will be updated and as a result the visualization will be updated as well.
#### Set a simulation parameter: set the value of a parameter, probCatch, for a simulation, Fire, based on the value given in an XML fire
The Game class will be responsible to read in initial parameters and configurations of the grid, if given. Next, this parameter will be applied to the corresponding rule in the rules class as part of the initialization, and the simulation will begin when the user presses the start button.
#### Switch simulations: use the GUI to change the current simulation from Game of Life to Wator
The user can pause the simulation (or not pause). Then the user must click on the drop down menu on the side of what simulation to run and click on Wator. The Game class will load the new game and initialize simulation over again with Wator.

## Design Considerations 

This section describes any issues which need to be addressed or resolved before attempting to devise a complete design solution. It should include any design decisions that the group discussed at length (include pros and cons from all sides of the discussion) as well as any assumptions or dependencies regarding the program that impact the overall design. This section should go into as much detail as necessary to cover all your team wants to say.

## Team Responsibilities
The idea at the moment is to split up the code as follows: Sam Schwaller will handle the UI code. Nikita Zemlevskiy and Elliott will split up the backend as follows: Nikita will handle creating the Grid and Cell and Game and Simulation classes (and their subclasses where appropriate), and Elliott will handle the State and Rule classes (and their subclasses where appropriate). We will each debug and test our portions of the code and will all be involved in refactoring our work together. Nikita will be responsible for merging the code when it is ready. 
